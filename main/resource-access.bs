Authenticated Resource Access {#resource-access}
================================================

Issue: Write introduction to the Authenticated Resource Access section.

## Hypertext Transfer Protocol ## {#http}

### Background and Need ### {#http-need}
<em>This section is non-normative.</em>

Solid clients and servers need to exchange data securely over the Internet,
and they do so using the HTTP Web standard.
This section describes in detail
which parts of HTTP must be implemented by clients and servers.

### Required server-side implementation ### {#http-server}

A [=data pod=] MUST be an HTTP/1.1 server [[!RFC7230]][[!RFC7231]].
It SHOULD additionally be an HTTP/2 server [[!RFC7540]]
to improve performance,
especially in cases where individual clients
are expected to send high numbers of successive requests.

A data pod SHOULD use TLS connections
through the `https` URI scheme
in order to secure the communication between clients and servers.
When both `http` and `https` are supported,
all `http` URIs MUST redirect to their `https` counterparts
using a response with a `301` status code and a `Location` header.

A data pod MUST implement the server part
of <cite>HTTP/1.1 Conditional Requests</cite> [[!RFC7232]]
to ensure that updates requested by clients
will only be applied if given preconditions are met.
It SHOULD additionally implement the server part
of <cite>HTTP/1.1 Caching</cite> [[!RFC7234]]
to improve performance.
A data pod MAY implement the server part
of <cite>HTTP/1.1 Range Requests</cite> [[!RFC7233]]
to further improve performance for large representations.

A data pod MUST implement the server part
of <cite>HTTP/1.1 Authentication</cite> [[!RFC7235]].
When a client does not provide valid credentials
when requesting a resource that requires it (see [[#webid]]),
the data pod MUST send a response with a `401` status code
(unless `404` is preferred for security reasons).

### Required client-side implementation ### {#http-client}

A Solid client MUST be an HTTP/1.1 client [[!RFC7230]][[!RFC7231]].
It MAY additionally be an HTTP/2 client [[!RFC7540]]
to improve performance.

A Solid client MAY implement the client parts of
<cite>HTTP/1.1 Conditional Requests</cite> [[!RFC7232]]
to only trigger updates when certain preconditions are met.
It MAY implement
<cite>HTTP/1.1 Caching</cite> [[!RFC7234]]
and
<cite>HTTP/1.1 Range Requests</cite> [[!RFC7233]]
to improve performance.

A Solid client MUST implement the client part
of <cite>HTTP/1.1 Authentication</cite> [[!RFC7235]]
if it needs to access resources requiring authentication (see [[#webid]]).
When it receives a response with a `403` or `404` status code,
it MAY repeat the request with different credentials.


## Linked Data Platform ## {#ldp}

Issue: Write Linked Data Platform section.

Draft:
A Solid data pod MUST conform to the LDP specification [[!LDP]].

## Resource Metadata ## {#rm}

### Background and Need ### {#rm-need}
<em>This section is non-normative.</em>

This section introduces a mechanism for linking to metadata about resources
in the Solid Ecosystem using HTTP Link headers. The metadata may serve as
supplementary descriptions or, when supported by a Solid server implementation,
may influence the behavior of the resources. A given resource might link to zero
or more such related metadata representations. It is not meant to replace the
ability for the directly associated resource to self-describe.

Examples of this mechanism in use include:

<ul>
  <li>A binary JPEG image with a Link header, pointing to a description that has
  an RDF representation.</li>
  <li>A container with a Link header, pointing to an ACL resource that governs
  access controls for the contained resources.</li>
  <li>A resource whose shape is constrained by a ShEx schema includes a Link
  header that points to a metadata resource defining that constraint.</li>
  <li>A resource with an associated set of configurable parameters includes a
  Link header that points to a resource where those configurable parameters
  reside.</li>
</ul>

### Metadata Discovery ###  {#rm-discovery}

To discover the metadata resources directly associated with a given target
resource, a client MUST issue a `HEAD` or `GET` request to the target resource
URL and inspect the `Link` headers in the response, or make an HTTP `GET`
request on the target resource URL to retrieve an RDF representation, and
inspect the encoded RDF graph for relations of one or more metadata types. These
may be carried out in either order, but if the first fails to result in
discovering the metadata resource or the described resource, the second MUST be
tried.

Issue: It would seem that requiring that metadata MUST looked up through *both*
Link headers and the RDF graph is redundant and invites synchronization
problems. Suggest that the primary mechanism is through Link headers, and the
client MAY or SHOULD inspect the RDF graph for any additional metadata.

The `rel={relation-type}` [[!RFC8288]] will define the relationship to the
target URL in the `Link` header. Refer to [[!RFC8288]] for allowed [link
relation types](https://httpwg.org/specs/rfc8288.html#link-relation-types).

For any defined metadata type available for a given resource, all
representations of that resource MUST include a Link header pointing to the
location of each metadata resource. Metadata discovered through a Link header
for a given resource is considered to be *directly associated* with that
resource. Access to different types of metadata require varying levels of
authorization, which MUST be specified as part of the definition for a given
metadata type.

<p class="example">
As defined by [[!WAC]]), a client can use this mechanism to discover the
location of an ACL resource:<br/>
`Link: <https://server.example/acls/resource.acl>; rel="acl"`
</p>

The following table lists [[#rm-reserved]] and the associated link relation URIs
that are used for discovery. Other metadata types and relations may also be
used, and may be added to the reserved set in the future.

<table class="data" align="left">
  <colgroup class="header"></colgroup>
  <colgroup span="2"></colgroup>
  <thead>
    <tr>
      <th>Metadata Type</th>
      <th>Link Relation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[[#rm-wac]]</td>
      <td>```"acl"``` or ```http://www.w3.org/ns/solid/terms#acl```</td>
    </tr>
    <tr>
      <td>[[#rm-description]]</td>
      <td>```"describedby"``` or
```https://www.w3.org/ns/iana/link-relations/relation#describedby```</td>
    </tr>
    <tr>
      <td>[[#rm-shape]]</td>
      <td>```http://www.w3.org/ns/solid/terms#shape```</td>
    </tr>
    <tr>
      <td>[[#rm-managed]]</td>
      <td>```http://www.w3.org/ns/solid/terms#servermanaged```</td>
    </tr>
    <tr>
      <td>[[#rm-configuration]]</td>
      <td>```http://www.w3.org/ns/solid/terms#configuration```</td>
    </tr>
  </tbody>
</table>

#### Discovery of Annotated Resource #### {#rm-annotated}

Certain metadata resource types require the Solid server to link back to the
annotated resource that the metadata is directly associated with, via Link
headers. In these instances, the link relation ```rel=describes``` MUST be used.

<p class="example">
A metadata resource `<https://server.example/metadata/resource.meta>` is
directly associated with `<https://server.example/resource.ttl>`. The metadata
type for `resource.meta` requires linking back to the annotated resource, which
is `resource.ttl`. `resource.meta` must have the following included in its
`Link` headers:<br/>
`Link: <https://server.example/resource.ttl>; rel="describes"`
</p>

### Metadata Characteristics ### {#rm-characteristics}

A given resource MAY Link to metadata on a different server under a different
authority, per the configuration of the Solid server on which that resource
resides.

Metadata resources that reside on a Solid server MUST adhere to the same
interaction model used by other standard Solid resources, except where specified
in the definition of the associated metadata type in [[#rm-reserved]].

A metadata resource MUST be deleted by the Solid server when the resource it is
directly associated with is also deleted and the Solid server is authoritative
for both resources.

### Reserved Metadata Types ### {#rm-reserved}

#### Web Access Control #### {#rm-wac}

ACL resources as defined by [[!WAC]] MUST be supported as a resource metadata
type by Solid servers.

The ACL metadata resource directly associated with a given resource is
discovered by the client via the `rel="acl"` `Link` relation in a `Link` header.

A given Solid resource MUST NOT be directly associated with more than one ACL
metadata resource. A given ACL metadata resource MUST NOT be directly associated
with more than one Solid resource.

To discover, read, create, or modify an ACL metadata resource, an
[acl:agent](https://github.com/solid/web-access-control-spec#describing-agents)
MUST have
[acl:Control](https://github.com/solid/web-access-control-spec#aclcontrol)
privileges per the [ACL inheritance
algorithm](https://github.com/solid/web-access-control-spec#acl-inheritance-algorithm)
on the resource directly associated with it.

An ACL metadata resource MUST NOT be deleted unless the resource directly
associated with it is deleted.

A Solid server SHOULD sanity check ACL metadata resources upon creation or
update to restrict invalid changes, such as by performing shape validation
against authorization statements therein.

#### Resource Description #### {#rm-description}

Issue: Identify any resource description metadata parameters that MUST be
recognized by all implementations.

Resource description is a general mechanism to provide descriptive metadata for
a given resource. It MUST be supported as a resource metadata type by Solid
servers.

The Descriptive metadata resource directly associated with a given resource is
discovered by the client via the `"rel=describedby"` `Link` relation in a `Link`
header. Conversely, the resource being described by a Descriptive metadata
resource is discovered by the client via the `rel="describes"` `Link` relation
in a `Link` header.

A given Solid resource MUST NOT be directly associated with more than one
Descriptive metadata resource.

To create or modify a Descriptive metadata resource, a given
[acl:agent](https://github.com/solid/web-access-control-spec#describing-agents)
MUST have
[acl:Write](https://github.com/solid/web-access-control-spec#aclcontrol)
privileges per the [ACL inheritance
algorithm](https://github.com/solid/web-access-control-spec#acl-inheritance-algorithm)
on the resource directly associated with it.

To discover or read a Descriptive metadata resource, an
[acl:agent](https://github.com/solid/web-access-control-spec#describing-agents)
MUST have
[acl:Read](https://github.com/solid/web-access-control-spec#aclcontrol)
privileges per the [ACL inheritance
algorithm](https://github.com/solid/web-access-control-spec#acl-inheritance-algorithm)
on the resource directly associated with it.

#### Shape Validation #### {#rm-shape}

Issue: Detail the composition of a shape metadata resource, including the shape
language, shape url, and any additional parameters to be used in shape
validation by the server implementation.

Shape Validation ensures that any data changes in a given resource conform to an
associated [[!SHACL]] or [[!SHEX]] data shape. It MUST be supported as a
resource metadata type by Solid servers.

The Shape validation metadata resource directly associated with a given resource
is discovered by the client via the `rel=http://www.w3.org/ns/solid/terms#shape`
`Link` relation in a `Link` header. Conversely, the resource being described by
a Shape validation metadata resource is discovered by the client via the
`rel=describes` `Link` relation in a `Link` header.

A given Solid resource MUST NOT be directly associated with more than one
Descriptive metadata resource.

To create or modify a Shape validation metadata resource, an
[acl:agent](https://github.com/solid/web-access-control-spec#describing-agents)
MUST have
[acl:Write](https://github.com/solid/web-access-control-spec#aclcontrol)
privileges per the [ACL inheritance
algorithm](https://github.com/solid/web-access-control-spec#acl-inheritance-algorithm)
on the resource directly associated with it.

To read a Shape validation metadata resource, an
[acl:agent](https://github.com/solid/web-access-control-spec#describing-agents)
MUST have
[acl:Read](https://github.com/solid/web-access-control-spec#aclcontrol)
privileges per the [ACL inheritance
algorithm](https://github.com/solid/web-access-control-spec#acl-inheritance-algorithm)
on the resource directly associated with it.

A Solid server SHOULD sanity check Shape validation metadata resources upon
creation or update to restrict invalid changes.

#### Server Managed #### {#rm-managed}

Issue: Identify any metadata the server MUST be required to manage.

A Solid server stores information about a resource that clients can read but not
change in Server Managed metadata. Examples of Server Managed metadata could
include resource creation or modification timestamps, identity of the agent that
created the resource, etc. It MUST be supported as a resource metadata type by
Solid servers.

A Server Managed metadata resource directly associated with a given resource is
discovered by the client via the `rel=http://www.w3.org/ns/solid/terms#managed`
`Link` relation in a `Link` header. Conversely, the resource being described by
a Server Managed metadata resource is discovered by the client via the
`rel=describes` `Link` relation in a `Link` header.

A given Solid resource MUST NOT be directly associated with more than one Server
Managed metadata resource.

To read a Server Managed metadata resource, an
[acl:agent](https://github.com/solid/web-access-control-spec#describing-agents)
MUST have [acl:Read](https://github.com/solid/web-access-control-spec#aclread)
privileges per the [ACL inheritance
algorithm](https://github.com/solid/web-access-control-spec#acl-inheritance-algorithm)
on the resource directly associated with it. Modes of access beyond
[acl:Read](https://github.com/solid/web-access-control-spec#aclread) MUST NOT be
permitted on a Server Managed metadata resource.

#### Configuration #### {#rm-configuration}

Issue: Identify any configuration metadata parameters that MUST be recognized by
all implementations.

Configuration metadata is used to store configurable parameters for a given
resource. For example, whether to maintain
[Mementos](https://tools.ietf.org/html/rfc7089) for a given resource, or how the
data within a given resource should be rendered or indexed. It MUST be supported
as a resource metadata type by Solid servers.

A configuration metadata resource directly associated with a given resource is
discovered by the client via the
`rel=http://www.w3.org/ns/solid/terms#configuration` `Link` relation in a `Link`
header. Conversely, the resource being described by a Configuration metadata
resource is discovered by the client via the `rel=describes` `Link` relation in
a `Link header`.

A given Solid resource MUST NOT be directly associated with more than one
Configuration metadata resource.

To discover, read, create, or modify a Configuration metadata resource, an
[acl:agent](https://github.com/solid/web-access-control-spec#describing-agents)
MUST have
[acl:Control](https://github.com/solid/web-access-control-spec#aclcontrol)
privileges per the [ACL inheritance
algorithm](https://github.com/solid/web-access-control-spec#acl-inheritance-algorithm)
on the resource directly associated with it.


## WebID ## {#webid}

Issue: Explain inline that agents accessing non-public Solid resources
  need to authenticate with a WebID, which is a URL
  pointing to a document with an RDF representation.


### WebID-OIDC ### {#webid-oidc}

Issue: Write WebID-OIDC section.

Draft:
A Solid data pod MUST conform to the WebID-OIDC specification [[!WEBID-OIDC]].


### WebID-TLS ### {#webid-tls}

Issue: Write WebID-TLS section.

Draft:
A Solid data pod MAY conform to the WebID-TLS specification [[!WEBID-TLS]].


## Web Access Control ## {#wac}

Issue: Write Web Access Control section.

Draft:
A Solid data pod MUST conform to the Web Access Control specification [[!WAC]].


## Cross-Origin Resource Sharing ## {#cors}

### Background and Need ### {#cors-need}
<em>This section is non-normative.</em>

[=Solid apps=] typically access data from multiple sources.
However,
Web browsers by default prevent apps that run on one origin
from accessing data on other origins.
This cross-origin protection is a security mechanism
that ensures malicious websites cannot simply read
your profile or banking details from other websites.
However, this reasonable default poses a problem
even for benevolent Solid apps,
which might have good reasons to access data from different places.
For instance,
a Solid app at `https://app.example/`
would be prevented from accessing data on
`https://alice-data-pod.example/` or `https://bob-data-pod.example/`,
even when Alice and Bob have given the user of the app
their permission to see some of their data.

For cases where the other origins
have their own access protection mechanism—
[like within Solid](#wac)—
the browser's built-in cross-origin protection
is actually an obstacle rather than a feature.
After all,
[=data pods=] already ensure through access control
that certain documents can only be accessed
by specific people or applications.
Preventively blocking apps from different origins
thus introduces an unnecessary barrier.

Fortunately,
Web servers can indicate to the browser
that certain documents do not require cross-origin protection.
This mechanism to selectively disable that protection
is called *Cross-Origin Resource Sharing* or *CORS* [[FETCH]].
By responding to browser requests
with a specific combination of HTTP headers,
servers can indicate which actions are allowed for a given resource.
For a Solid data pod,
the goal is to allow *all* actions on the CORS level,
such that the deeper [access control layer](#wac)
can exert full control over the app's allowed permissions.
The next section describes how to achieve this
through the right HTTP header configuration.


### Required server-side implementation ### {#cors-server}

A [=data pod=] MUST implement the CORS protocol [[!FETCH]]
such that, to the extent possible,
the browser allows Solid apps
to send any request and combination of request headers
to the data pod,
and the Solid app can read any response and response headers
received from the data pod.
If the data pod wishes to block access to a resource,
this MUST NOT happen via CORS
but MUST instead be communicated to the Solid app in the browser
through HTTP status codes such as
`401`, `403`, or `404` [[!RFC7231]].

Note: Since the CORS protocol is part of a Living Standard,
it might be changed at any point,
which might necessitate changes to data pod implementations
for continued prevention of undesired blocking.
A [proposal](https://github.com/whatwg/fetch/issues/878) to mitigate this
has been suggested.

Concretely,
whenever a data pod receives an HTTP request
containing a valid `Origin` header [[!RFC6454]],
the server MUST respond with the appropriate `Access-Control-*` headers
as specified in the CORS protocol [[!FETCH]].
In particular,
the data pod MUST set the `Access-Control-Allow-Origin` header
to the valid `Origin` value from the request
and list `Origin` in the `Vary` header value.
The data pod MUST make all used response headers readable for the Solid app
through `Access-Control-Expose-Headers`
(with the possible exception of the `Access-Control-*` headers themselves).
A data pod MUST also support the HTTP `OPTIONS` method [[!RFC7231]]
such that it can respond appropriately to CORS preflight requests.

Careful attention is warranted,
especially because of the many edge cases.
For instance,
data pods SHOULD explicitly enumerate
all used response headers under `Access-Control-Expose-Headers`
rather than resorting to `*`,
which does not cover all cases (such as credentials mode set to `include`).
Data pods SHOULD also explicitly list `Accept` under
`Access-Control-Allow-Headers`,
because values longer than 128 characters
(not uncommon for RDF-based Solid apps)
would otherwise be blocked,
despite shorter `Accept` headers being allowed without explicit mention.
